// Generated by CoffeeScript 1.7.1
var Context, DEFINITIONS, Runtime, URI, clone, escape, _ref,
  __slice = [].slice;

URI = require("./uri");

_ref = require("./util"), escape = _ref.escape, Runtime = _ref.Runtime, Context = _ref.Context;

clone = function(value) {
  return JSON.parse(JSON.stringify(value));
};

DEFINITIONS = {
  "http://json-schema.org/draft-03/schema#": require("../schemas/draft-03/schema.json"),
  "http://json-schema.org/draft-04/schema#": require("../schemas/draft-04/schema.json")
};

module.exports = function(_arg) {
  var SCHEMA_URI, Validator, mixins, schema_uri;
  schema_uri = _arg.schema_uri, mixins = _arg.mixins;
  SCHEMA_URI = schema_uri;
  return Validator = (function() {
    var common, common_modules, method, mixin, name, _i, _len;

    Validator.modifiers = {
      patternProperties: ["additionalProperties"],
      additionalProperties: ["properties", "patternProperties"],
      items: ["additionalItems"],
      minimum: ["exclusiveMinimum"],
      maximum: ["exclusiveMaximum"]
    };

    common_modules = {
      "type": require("./common/type"),
      "numeric": require("./common/numeric"),
      "comparison": require("./common/comparison"),
      "arrays": require("./common/arrays"),
      "objects": require("./common/objects"),
      "strings": require("./common/strings")
    };

    common = (function() {
      var _results;
      _results = [];
      for (name in common_modules) {
        mixin = common_modules[name];
        _results.push((function() {
          var _results1;
          _results1 = [];
          for (name in mixin) {
            method = mixin[name];
            _results1.push(Validator.prototype[name] = method);
          }
          return _results1;
        })());
      }
      return _results;
    })();

    for (_i = 0, _len = mixins.length; _i < _len; _i++) {
      mixin = mixins[_i];
      for (name in mixin) {
        method = mixin[name];
        Validator.prototype[name] = method;
      }
    }

    function Validator() {
      var schema, schemas, _j, _len1;
      schemas = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.uris = {};
      this.media_types = {};
      this.unresolved = {};
      this.options = {};
      this.add(DEFINITIONS[SCHEMA_URI]);
      for (_j = 0, _len1 = schemas.length; _j < _len1; _j++) {
        schema = schemas[_j];
        if ((schema["$schema"] != null) && schema["$schema"] !== SCHEMA_URI) {
          throw "This validator doesn't support this JSON schema.";
        }
        this.add(schema);
      }
    }

    Validator.prototype.set_options = function(args) {
      this.options = args;
      return this;
    };

    Validator.prototype.add = function(schema) {
      var context;
      schema = clone(schema);
      if (schema.id) {
        schema.id = schema.id.replace(/#?$/, "#");
      }
      context = new Context({
        pointer: schema.id || "#",
        scope: schema.id || "#"
      });
      this.compile_references(context, schema);
      return this.compile(context, schema);
    };

    Validator.prototype.validate = function(data) {
      return this.validator("#").validate(data);
    };

    Validator.prototype.validator = function(arg) {
      var schema;
      if ((schema = this.find(arg)) != null) {
        return {
          validate: (function(_this) {
            return function(data) {
              var attribute, base, error, errors, pointer, runtime, valid, _base, _j, _k, _len1, _ref1, _ref2;
              errors = [];
              runtime = new Runtime({
                errors: errors,
                pointer: "#"
              });
              schema._test(data, runtime);
              if (errors.length > 0) {
                for (_j = 0, _len1 = errors.length; _j < _len1; _j++) {
                  error = errors[_j];
                  _ref1 = error.schema.pointer.split("/"), base = 2 <= _ref1.length ? __slice.call(_ref1, 0, _k = _ref1.length - 1) : (_k = 0, []), attribute = _ref1[_k++];
                  pointer = base.join("/");
                  if ((_base = error.schema).definition == null) {
                    _base.definition = (_ref2 = _this.resolve_uri(pointer)) != null ? _ref2[attribute] : void 0;
                  }
                  if (error.document.value === void 0) {
                    delete error.document.value;
                  }
                }
              }
              valid = runtime.errors.length === 0;
              return {
                valid: valid,
                errors: errors
              };
            };
          })(this),
          toJSON: function() {
            var args;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            return schema;
          }
        };
      } else {
        throw new Error("No schema found for '" + (JSON.stringify(arg)) + "'");
      }
    };

    Validator.prototype.find = function(arg) {
      var media_type, uri;
      if (this.test_type("string", arg)) {
        uri = escape(arg);
        return this.uris[uri];
      } else if ((uri = arg.uri) != null) {
        uri = escape(uri);
        return this.uris[uri];
      } else if ((media_type = arg.mediaType) != null) {
        return this.media_types[media_type];
      } else {
        return null;
      }
    };

    Validator.prototype.resolve_uri = function(uri, scope) {
      var schema;
      if ((schema = this.find(uri)) != null) {
        if (schema.$ref) {
          return this.resolve_uri(URI.resolve(scope, schema.$ref));
        } else {
          return schema;
        }
      }
    };

    Validator.prototype.register = function(uri, schema) {
      var media_type;
      this.uris[uri] = schema;
      if ((media_type = schema.mediaType) != null) {
        if (media_type !== "application/json") {
          return this.media_types[media_type] = schema;
        }
      }
    };

    Validator.prototype.compile_references = function(context, schema) {
      var found_schema, key, pointers, ref, scope, uri, _ref1, _ref2;
      this.schema_references(context, schema);
      _ref1 = this.unresolved;
      for (ref in _ref1) {
        _ref2 = _ref1[ref], scope = _ref2.scope, uri = _ref2.uri;
        if ((found_schema = this.resolve_uri(uri, scope)) != null) {
          delete this.unresolved[ref];
          this.register(ref, found_schema);
        }
      }
      if (Object.keys(this.unresolved).length > 0) {
        pointers = (function() {
          var _ref3, _results;
          _ref3 = this.unresolved;
          _results = [];
          for (key in _ref3) {
            uri = _ref3[key].uri;
            _results.push(uri);
          }
          return _results;
        }).call(this);
        throw new Error("Unresolvable $ref values: " + (JSON.stringify(pointers)));
      }
    };

    Validator.prototype.schema_references = function(context, schema) {
      var attribute, definition, i, new_context, pointer, s, scope, uri, _results;
      if (!this.test_type("object", schema)) {
        throw new Error("Schema must be an object - " + context.pointer);
      }
      scope = context.scope, pointer = context.pointer;
      this.register(pointer, schema);
      if (schema.id && schema.id.indexOf("#") === 0) {
        uri = URI.resolve(scope, schema.id);
        schema.id = uri;
        this.register(uri, schema);
      }
      _results = [];
      for (attribute in schema) {
        definition = schema[attribute];
        if ("$ref" === attribute) {
          _results.push(this.resolve_reference(context, schema, definition));
        } else {
          new_context = context.child(attribute);
          if ("properties" === attribute) {
            _results.push(this.properties_references(new_context, definition));
          } else if ("items" === attribute) {
            _results.push(this.items_references(new_context, definition));
          } else if ("definitions" === attribute) {
            _results.push(this.definitions_references(new_context, definition));
          } else if (this.test_type("object", definition)) {
            _results.push(this.schema_references(new_context, definition));
          } else if (attribute === "allOf" || attribute === "anyOf" || attribute === "not") {
            _results.push((function() {
              var _j, _len1, _results1;
              _results1 = [];
              for (i = _j = 0, _len1 = definition.length; _j < _len1; i = ++_j) {
                s = definition[i];
                _results1.push(this.schema_references(new_context.child(i), s));
              }
              return _results1;
            }).call(this));
          } else {
            _results.push(void 0);
          }
        }
      }
      return _results;
    };

    Validator.prototype.resolve_reference = function(context, schema, definition) {
      var found_schema, k, pointer, scope, uri, v;
      scope = context.scope, pointer = context.pointer;
      uri = URI.resolve(scope, definition);
      if (pointer.indexOf(uri + "/") !== 0) {
        if ((found_schema = this.resolve_uri(uri, scope)) != null) {
          delete schema.$ref;
          for (k in found_schema) {
            v = found_schema[k];
            schema[k] = v;
          }
          return this.schema_references(context, schema);
        } else {
          return this.unresolved[pointer] = {
            scope: scope,
            uri: uri
          };
        }
      }
    };

    Validator.prototype.properties_references = function(context, properties) {
      var property, schema, _results;
      if (!this.test_type("object", properties)) {
        throw new Error("Properties must be an object - " + context.pointer);
      }
      _results = [];
      for (property in properties) {
        schema = properties[property];
        _results.push(this.schema_references(context.child(property), schema));
      }
      return _results;
    };

    Validator.prototype.items_references = function(context, definition) {
      var def, i, _j, _len1, _results;
      if (this.test_type("array", definition)) {
        _results = [];
        for (i = _j = 0, _len1 = definition.length; _j < _len1; i = ++_j) {
          def = definition[i];
          _results.push(this.schema_references(context.child(i), def));
        }
        return _results;
      } else {
        return this.schema_references(context, definition);
      }
    };

    Validator.prototype.definitions_references = function(context, object) {
      var schema, _results;
      if (!this.test_type("object", object)) {
        throw new Error("Value of 'definitions' must be an object - " + context.pointer);
      }
      _results = [];
      for (name in object) {
        schema = object[name];
        _results.push(this.schema_references(context.child(name), schema));
      }
      return _results;
    };

    Validator.prototype.compile = function(context, schema) {
      var definition, key, new_context, pointer, scope, test, test_function, tests, uri, _ref1, _ref2;
      scope = context.scope, pointer = context.pointer;
      tests = [];
      if ((uri = schema.$ref) != null) {
        if (this.uris[uri]) {
          return (function(_this) {
            return function() {
              var args, _ref1;
              args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
              return (_ref1 = _this.uris[uri])._test.apply(_ref1, args);
            };
          })(this);
        }
        uri = URI.resolve(scope, uri);
        if (pointer.indexOf(uri) === 0) {
          return this.recursive_test(schema, context);
        }
        schema = this.find(uri);
        if (!schema) {
          throw new Error("No schema found for $ref '" + uri + "'");
        }
      }
      for (key in schema) {
        definition = schema[key];
        if (!(key !== "_test")) {
          continue;
        }
        new_context = context.attribute(key);
        if (this[key] != null) {
          test = this.compile_attribute(new_context, key, schema, definition);
          if (test) {
            tests.push(test);
          }
        } else {
          this.compile_definitions(new_context, definition);
        }
      }
      test_function = function(data, runtime) {
        var _j, _len1;
        if (typeof data === "undefined") {
          return null;
        }
        runtime.tested_item();
        for (_j = 0, _len1 = tests.length; _j < _len1; _j++) {
          test = tests[_j];
          test(data, runtime);
        }
        return null;
      };
      if ((_ref1 = this.find(pointer)) != null) {
        _ref1._test = test_function;
      }
      if (schema.id) {
        uri = URI.resolve(scope, schema.id);
        if ((_ref2 = this.find(uri)) != null) {
          _ref2._test = test_function;
        }
      }
      return test_function;
    };

    Validator.prototype.compile_attribute = function(context, attribute, schema, definition) {
      var key, modifiers, test, _j, _len1;
      context.modifiers = {};
      if ((modifiers = Validator.modifiers[attribute]) != null) {
        for (_j = 0, _len1 = modifiers.length; _j < _len1; _j++) {
          key = modifiers[_j];
          context.modifiers[key] = schema[key];
        }
      }
      if (this[attribute] != null) {
        if ((test = this[attribute](definition, context)) != null) {
          return test;
        }
      }
    };

    Validator.prototype.compile_definitions = function(context, object) {
      var definition, _results;
      if (this.is_schema(object)) {
        return this.compile(context, object);
      } else if (this.test_type("object", object)) {
        _results = [];
        for (name in object) {
          definition = object[name];
          _results.push(this.compile_definitions(context.child(name), definition));
        }
        return _results;
      }
    };

    Validator.prototype.is_schema = function(object) {
      return (object.type != null) || (object.$ref != null) || (object.allOf != null) || (object.anyOf != null) || (object.not != null);
    };

    Validator.prototype.recursive_test = function(schema, _arg1) {
      var pointer, scope, uri;
      scope = _arg1.scope, pointer = _arg1.pointer;
      uri = URI.resolve(scope, schema.$ref);
      if ((schema = this.find(uri)) != null) {
        return function(data, runtime) {
          return schema._test(data, runtime);
        };
      } else {
        throw new Error("No schema found for $ref '" + uri + "'");
      }
    };

    return Validator;

  })();
};
