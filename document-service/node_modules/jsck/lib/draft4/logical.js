// Generated by CoffeeScript 1.7.1
module.exports = {
  anyOf: function(definition, context) {
    var i, new_context, schema, tests, _i, _len;
    if (!this.test_type("array", definition)) {
      throw new Error("The 'anyOf' attribute must be an array");
    }
    if (definition.length === 0) {
      throw new Error("The 'anyOf' array may not be empty");
    }
    tests = [];
    for (i = _i = 0, _len = definition.length; _i < _len; i = ++_i) {
      schema = definition[i];
      if (!this.test_type("object", schema)) {
        throw new Error("The 'anyOf' array values must be objects");
      }
      new_context = context.child(i);
      tests.push(this.compile(new_context, schema));
    }
    return (function(_this) {
      return function(data, runtime) {
        var answer, best_errors, most_items_tested;
        most_items_tested = 0;
        best_errors = [];
        answer = tests.some(function(test) {
          var temp;
          temp = new runtime.constructor({
            pointer: "",
            error_pointer: runtime.pointer,
            errors: []
          });
          test(data, temp);
          if (temp.items_tested && temp.items_tested > most_items_tested) {
            best_errors = temp.errors;
            most_items_tested = temp.items_tested;
          }
          return temp.errors.length === 0;
        });
        if (!answer) {
          if (_this.options.closestMatch) {
            return Array.prototype.push.apply(runtime.errors, best_errors);
          } else {
            return runtime.error(context, data);
          }
        }
      };
    })(this);
  },
  allOf: function(definition, context) {
    var i, new_context, schema, tests, _i, _len;
    if (!this.test_type("array", definition)) {
      throw new Error("The 'allOf' attribute must be an array");
    }
    if (definition.length === 0) {
      throw new Error("The 'allOf' array may not be empty");
    }
    tests = [];
    for (i = _i = 0, _len = definition.length; _i < _len; i = ++_i) {
      schema = definition[i];
      if (!this.test_type("object", schema)) {
        throw new Error("The 'allOf' array values must be objects");
      }
      new_context = context.child(i);
      tests.push(this.compile(new_context, schema));
    }
    return (function(_this) {
      return function(data, runtime) {
        var test, _j, _len1;
        for (_j = 0, _len1 = tests.length; _j < _len1; _j++) {
          test = tests[_j];
          test(data, runtime);
        }
        return null;
      };
    })(this);
  },
  oneOf: function(definition, context) {
    var i, new_context, schema, tests, _i, _len;
    if (!this.test_type("array", definition)) {
      throw new Error("The 'oneOf' attribute must be an array");
    }
    if (definition.length === 0) {
      throw new Error("The 'oneOf' array may not be empty");
    }
    tests = [];
    for (i = _i = 0, _len = definition.length; _i < _len; i = ++_i) {
      schema = definition[i];
      if (!this.test_type("object", schema)) {
        throw new Error("The 'oneOf' array values must be objects");
      }
      new_context = context.child(i);
      tests.push(this.compile(new_context, schema));
    }
    return (function(_this) {
      return function(data, runtime) {
        var best_errors, most_items_tested, temp, test, valids, _j, _len1;
        valids = 0;
        most_items_tested = 0;
        best_errors = [];
        for (_j = 0, _len1 = tests.length; _j < _len1; _j++) {
          test = tests[_j];
          temp = new runtime.constructor({
            pointer: "",
            error_pointer: runtime.pointer,
            errors: []
          });
          test(data, temp);
          if (temp.errors.length === 0) {
            valids++;
          } else {
            if (temp.items_tested && temp.items_tested > most_items_tested) {
              best_errors = temp.errors;
              most_items_tested = temp.items_tested;
            }
          }
        }
        if (valids === 0 && _this.options.closestMatch) {
          return Array.prototype.push.apply(runtime.errors, best_errors);
        } else if (valids !== 1) {
          return runtime.error(context, data);
        }
      };
    })(this);
  },
  not: function(definition, context) {
    var inverse;
    if (!this.test_type("object", definition)) {
      throw new Error("The 'not' attribute must be an object");
    }
    inverse = this.compile(context, definition);
    return (function(_this) {
      return function(data, runtime) {
        var temp;
        temp = new runtime.constructor({
          pointer: "",
          errors: []
        });
        inverse(data, temp);
        if (temp.errors.length === 0) {
          return runtime.error(context, data);
        }
      };
    })(this);
  }
};
