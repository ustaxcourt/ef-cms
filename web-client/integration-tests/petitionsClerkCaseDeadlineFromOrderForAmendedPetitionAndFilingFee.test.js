import {
  DOCUMENT_SERVED_MESSAGES,
  PAYMENT_STATUS,
  SYSTEM_GENERATED_DOCUMENT_TYPES,
} from '../../shared/src/business/entities/EntityConstants';
import { docketClerkCreatesAnOrder } from './journey/docketClerkCreatesAnOrder';
import { docketClerkGetsDocketEntryByEventCode } from './journey/docketClerkGetsDocketEntryByEventCode';
import { docketClerkServesASavedCourtIssuedDocumentFromDocumentView } from './journey/docketClerkServesASavedCourtIssuedDocumentFromDocumentView';
import { docketClerkSignsOrder } from './journey/docketClerkSignsOrder';
import { docketClerkViewsAutoGeneratedCaseDeadline } from './journey/docketClerkViewsAutoGeneratedCaseDeadline';
import { fakeFile, loginAs, setupTest, waitForCondition } from './helpers';
import { petitionsClerkCreatesNewCaseFromPaper } from './journey/petitionsClerkCreatesNewCaseFromPaper';
import { petitionsClerkReviewsPaperCaseBeforeServing } from './journey/petitionsClerkReviewsPaperCaseBeforeServing';
import { petitionsClerkServesPaperCaseToIRS } from './userFlows/petitionsClerkServesPaperCaseToIRS';

let formOverrides = [{ key: 'orderForFilingFee', value: false }];

describe('Autogenerate Deadline when Order For Amended Petition and Filing Fee (OAPF) is served', () => {
  const cerebralTest = setupTest();

  beforeAll(() => {
    jest.setTimeout(40000);
  });

  afterAll(() => {
    cerebralTest.closeSocket();
  });

  describe('Create and serve docket entry immediately', () => {
    loginAs(cerebralTest, 'petitionsclerk@example.com');

    petitionsClerkCreatesNewCaseFromPaper(
      cerebralTest,
      fakeFile,
      {
        formOrdersAndNotices: {
          key: 'orderForAmendedPetitionAndFilingFee',
          value: true,
        },
        paymentStatus: PAYMENT_STATUS.UNPAID,
      },
      formOverrides,
    );

    petitionsClerkReviewsPaperCaseBeforeServing(cerebralTest, {
      hasIrsNoticeFormatted: 'No',
      ordersAndNoticesInDraft: [
        'Order Designating Place of Trial',
        'Order for Amended Petition and Filing Fee',
      ],
      ordersAndNoticesNeeded: ['Order for Ratification of Petition'],
      petitionPaymentStatusFormatted: `${PAYMENT_STATUS.UNPAID}`,
      receivedAtFormatted: '01/01/01',
      shouldShowIrsNoticeDate: false,
    });

    petitionsClerkServesPaperCaseToIRS(cerebralTest);

    loginAs(cerebralTest, 'docketclerk@example.com');

    docketClerkGetsDocketEntryByEventCode(
      cerebralTest,
      SYSTEM_GENERATED_DOCUMENT_TYPES.orderForAmendedPetitionAndFilingFee
        .eventCode,
    );

    docketClerkSignsOrder(cerebralTest);

    it('docket clerk adds a docket entry for Order For Amended Petition and Filing Fee (OAPF) and serves it', async () => {
      await cerebralTest.runSequence('gotoAddCourtIssuedDocketEntrySequence', {
        docketEntryId: cerebralTest.docketEntryId,
        docketNumber: cerebralTest.docketNumber,
      });

      const docketEntryFormData = {
        day: '2',
        month: '2',
        year: '2050',
      };

      for (const [key, value] of Object.entries(docketEntryFormData)) {
        await cerebralTest.runSequence(
          'updateCourtIssuedDocketEntryFormValueSequence',
          {
            key,
            value,
          },
        );
      }

      await cerebralTest.runSequence(
        'fileAndServeCourtIssuedDocumentFromDocketEntrySequence',
      );

      await waitForCondition({
        booleanExpressionCondition: () =>
          cerebralTest.getState('currentPage') === 'PrintPaperService',
      });

      expect(cerebralTest.getState('validationErrors')).toEqual({});
      expect(cerebralTest.getState('currentPage')).toEqual('PrintPaperService');
      expect(cerebralTest.getState('alertSuccess').message).toEqual(
        DOCUMENT_SERVED_MESSAGES.GENERIC,
      );
    });

    docketClerkViewsAutoGeneratedCaseDeadline({
      cerebralTest,
      expectedDeadlineDescription:
        SYSTEM_GENERATED_DOCUMENT_TYPES.orderForAmendedPetitionAndFilingFee
          .deadlineDescription,
    });
  });

  describe('Create docket entry (OAPF), save for later, then serve', () => {
    loginAs(cerebralTest, 'petitionsclerk@example.com');

    petitionsClerkCreatesNewCaseFromPaper(
      cerebralTest,
      fakeFile,
      {
        formOrdersAndNotices: {
          key: 'orderForAmendedPetitionAndFilingFee',
          value: true,
        },
        paymentStatus: PAYMENT_STATUS.UNPAID,
      },
      formOverrides,
    );

    petitionsClerkReviewsPaperCaseBeforeServing(cerebralTest, {
      hasIrsNoticeFormatted: 'No',
      ordersAndNoticesInDraft: [
        'Order Designating Place of Trial',
        'Order for Amended Petition and Filing Fee',
      ],
      ordersAndNoticesNeeded: ['Order for Ratification of Petition'],
      petitionPaymentStatusFormatted: `${PAYMENT_STATUS.UNPAID}`,
      receivedAtFormatted: '01/01/01',
      shouldShowIrsNoticeDate: false,
    });

    petitionsClerkServesPaperCaseToIRS(cerebralTest);

    loginAs(cerebralTest, 'docketclerk@example.com');

    docketClerkGetsDocketEntryByEventCode(
      cerebralTest,
      SYSTEM_GENERATED_DOCUMENT_TYPES.orderForAmendedPetitionAndFilingFee
        .eventCode,
    );

    docketClerkSignsOrder(cerebralTest);

    it('docket clerk adds a docket entry for Order For Amended Petition and Filing Fee (OAPF) and saves it', async () => {
      await cerebralTest.runSequence('gotoAddCourtIssuedDocketEntrySequence', {
        docketEntryId: cerebralTest.docketEntryId,
        docketNumber: cerebralTest.docketNumber,
      });

      const docketEntryFormData = {
        day: '2',
        month: '2',
        year: '2050',
      };

      for (const [key, value] of Object.entries(docketEntryFormData)) {
        await cerebralTest.runSequence(
          'updateCourtIssuedDocketEntryFormValueSequence',
          {
            key,
            value,
          },
        );
      }

      await cerebralTest.runSequence('submitCourtIssuedDocketEntrySequence');

      await waitForCondition({
        booleanExpressionCondition: () =>
          cerebralTest.getState('currentPage') === 'CaseDetailInternal',
      });

      expect(cerebralTest.getState('validationErrors')).toEqual({});
      expect(cerebralTest.getState('currentPage')).toEqual(
        'CaseDetailInternal',
      );
      expect(cerebralTest.getState('alertSuccess').message).toEqual(
        'Your entry has been added to the docket record.',
      );
    });

    docketClerkServesASavedCourtIssuedDocumentFromDocumentView(cerebralTest);

    docketClerkViewsAutoGeneratedCaseDeadline({
      cerebralTest,
      expectedDeadlineDescription:
        SYSTEM_GENERATED_DOCUMENT_TYPES.orderForAmendedPetitionAndFilingFee
          .deadlineDescription,
    });
  });

  describe('Create generic order, then update to Order For Amended Petition and Filing Fee (OAPF) during service', () => {
    loginAs(cerebralTest, 'petitionsclerk@example.com');

    petitionsClerkCreatesNewCaseFromPaper(
      cerebralTest,
      fakeFile,
      {
        paymentStatus: PAYMENT_STATUS.UNPAID,
      },
      formOverrides,
    );

    petitionsClerkReviewsPaperCaseBeforeServing(cerebralTest, {
      hasIrsNoticeFormatted: 'No',
      ordersAndNoticesInDraft: ['Order Designating Place of Trial'],
      ordersAndNoticesNeeded: ['Order for Ratification of Petition'],
      petitionPaymentStatusFormatted: `${PAYMENT_STATUS.UNPAID}`,
      receivedAtFormatted: '01/01/01',
      shouldShowIrsNoticeDate: false,
    });

    petitionsClerkServesPaperCaseToIRS(cerebralTest);

    loginAs(cerebralTest, 'docketclerk@example.com');
    docketClerkCreatesAnOrder(cerebralTest, {
      documentTitle: 'Order to do something',
      eventCode: 'O',
      expectedDocumentType: 'Order',
    });
    docketClerkSignsOrder(cerebralTest);

    it('docket clerk adds a docket entry for Order For Amended Petition and Filing Fee (OAPF) and serves it', async () => {
      await cerebralTest.runSequence('gotoAddCourtIssuedDocketEntrySequence', {
        docketEntryId: cerebralTest.docketEntryId,
        docketNumber: cerebralTest.docketNumber,
      });

      /* eslint-disable sort-keys-fix/sort-keys-fix */
      // Sorting object keys must be disabled, otherwise the date values
      // bubble to the top during sorting and cause the test to fail
      const docketEntryFormData = {
        documentType:
          SYSTEM_GENERATED_DOCUMENT_TYPES.orderForAmendedPetitionAndFilingFee
            .documentType,
        eventCode:
          SYSTEM_GENERATED_DOCUMENT_TYPES.orderForAmendedPetitionAndFilingFee
            .eventCode,
        scenario: 'Type D',
        day: '2',
        month: '2',
        year: '2050',
      };

      for (const [key, value] of Object.entries(docketEntryFormData)) {
        await cerebralTest.runSequence(
          'updateCourtIssuedDocketEntryFormValueSequence',
          {
            key,
            value,
          },
        );
      }

      await cerebralTest.runSequence(
        'fileAndServeCourtIssuedDocumentFromDocketEntrySequence',
      );

      await waitForCondition({
        booleanExpressionCondition: () =>
          cerebralTest.getState('currentPage') === 'PrintPaperService',
      });

      expect(cerebralTest.getState('validationErrors')).toEqual({});
      expect(cerebralTest.getState('currentPage')).toEqual('PrintPaperService');
      expect(cerebralTest.getState('alertSuccess').message).toEqual(
        DOCUMENT_SERVED_MESSAGES.GENERIC,
      );
    });

    docketClerkViewsAutoGeneratedCaseDeadline({
      cerebralTest,
      expectedDeadlineDescription:
        SYSTEM_GENERATED_DOCUMENT_TYPES.orderForAmendedPetitionAndFilingFee
          .deadlineDescription,
    });
  });
});
