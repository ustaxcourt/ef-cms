import { FORMATS } from '@shared/business/utilities/DateHandler';
import { PETITION_TYPES } from '@web-client/presenter/actions/setupPetitionStateAction';
import { applicationContextForClient as applicationContext } from '@web-client/test/createClientTestApplicationContext';
import { generatePetitionPdfAction } from '@web-client/presenter/actions/generatePetitionPdfAction';
import { presenter } from '../presenter-mock';
import { runAction } from '@web-client/presenter/test.cerebral';

describe('generatePetitionPdfAction', () => {
  beforeAll(() => {
    applicationContext
      .getUseCases()
      .generatePetitionPdfInteractor.mockImplementation(
        () =>
          new Promise(resolve =>
            resolve({
              fileId: 'TEST_FILE_ID',
              url: 'TEST_URL',
            }),
          ),
      );

    applicationContext
      .getUtilities()
      .formatDateString.mockImplementation(() => 'RESULTS_formatDateString');

    presenter.providers.applicationContext = applicationContext;
  });

  it('should not return/do anything if petition is not auto generated', async () => {
    const results = await runAction(generatePetitionPdfAction, {
      modules: {
        presenter,
      },
      state: {
        petitionFormatted: {
          petitionType: 'NOT AUTO GENERATED',
        },
      },
    });

    const generatePetitionPdfInteractorCalls =
      applicationContext.getUseCases().generatePetitionPdfInteractor.mock.calls;
    expect(generatePetitionPdfInteractorCalls.length).toEqual(0);

    expect(results.output).toEqual(undefined);
  });

  it('should generate the petition, save id in state and return URL when petition is auto generated and current step is not 5', async () => {
    const results = await runAction(generatePetitionPdfAction, {
      modules: {
        presenter,
      },
      state: {
        petitionFormatted: {
          noticeIssuedDate: 'TEST_noticeIssuedDate',
          petitionFileId: undefined,
          petitionProp: 'TEST_PROP',
          petitionType: PETITION_TYPES.autoGenerated,
        },
        stepIndicatorInfo: {
          currentStep: 6,
        },
      },
    });

    const generatePetitionPdfInteractorCalls =
      applicationContext.getUseCases().generatePetitionPdfInteractor.mock.calls;
    expect(generatePetitionPdfInteractorCalls.length).toEqual(1);
    expect(generatePetitionPdfInteractorCalls[0][1]).toEqual({
      isDraft: false,
      noticeIssuedDate: 'RESULTS_formatDateString',
      petitionFileId: undefined,
      petitionProp: 'TEST_PROP',
      petitionType: 'autoGenerated',
    });

    const formatDateStringCalls =
      applicationContext.getUtilities().formatDateString.mock.calls;
    expect(formatDateStringCalls.length).toEqual(1);
    expect(formatDateStringCalls[0][0]).toEqual('TEST_noticeIssuedDate');
    expect(formatDateStringCalls[0][1]).toEqual(FORMATS.MMDDYY);

    expect(results.output).toEqual({ pdfUrl: 'TEST_URL' });
    expect(results.state.petitionFormatted.petitionFileId).toEqual(
      'TEST_FILE_ID',
    );
  });

  it('should generate the petition, not save id in state and return URL when petition is auto generated and current step is 5', async () => {
    const results = await runAction(generatePetitionPdfAction, {
      modules: {
        presenter,
      },
      state: {
        petitionFormatted: {
          petitionFileId: undefined,
          petitionProp: 'TEST_PROP',
          petitionType: PETITION_TYPES.autoGenerated,
        },
        stepIndicatorInfo: {
          currentStep: 5,
        },
      },
    });

    const generatePetitionPdfInteractorCalls =
      applicationContext.getUseCases().generatePetitionPdfInteractor.mock.calls;
    expect(generatePetitionPdfInteractorCalls.length).toEqual(1);
    expect(generatePetitionPdfInteractorCalls[0][1]).toEqual({
      isDraft: true,
      noticeIssuedDate: 'RESULTS_formatDateString',
      petitionFileId: undefined,
      petitionProp: 'TEST_PROP',
      petitionType: 'autoGenerated',
    });

    const formatDateStringCalls =
      applicationContext.getUtilities().formatDateString.mock.calls;
    expect(formatDateStringCalls.length).toEqual(1);
    expect(formatDateStringCalls[0][0]).toEqual('');
    expect(formatDateStringCalls[0][1]).toEqual(FORMATS.MMDDYY);

    expect(results.output).toEqual({ pdfUrl: 'TEST_URL' });
    expect(results.state.petitionFormatted.petitionFileId).toEqual(undefined);
  });
});
