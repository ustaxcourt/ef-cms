pipeline {

  agent any

  environment {
    SPAWN_WRAP_SHIM_ROOT = "/home/tomcat"
    npm_config_cache = "/home/tomcat"
    HOME = "/home/tomcat" // needed to run 'npm i' on docker without being root
    CYPRESS_CACHE_FOLDER = "/home/tomcat/cypress_cache" // needed to be able to run cypress without being root
  }

  options { buildDiscarder(logRotator(daysToKeepStr: '3', artifactDaysToKeepStr: '3')) }

  stages {
    stage('Merge') {
      steps {
        script {
          if (env.branch_name != 'develop' && env.branch_name != 'staging' && env.branch_name != 'master' && env.target_sha1) {
            // todo: there is probably a better way to have Jenkins do this for us automatically
            sh 'git config user.name "EF-CMS Jenkins"'
            sh 'git config user.email "noop@example.com"'
            sh "git merge origin/${env.target_sha1}"
          }
        }
      }
    }
    stage('Setup') {
      steps {
        script {
          dir('web-client') {
            def runner = docker.build 'lint', '-f Dockerfile.test .'
            runner.inside('-v /home/tomcat:/home/tomcat') {
              sh 'npm i'
            }
          }
        }
      }
    }
    stage('ShellCheck') {
      steps {
        script {
          dir('web-client') {
            def runner = docker.build 'shellcheck', '-f Dockerfile.shellcheck .'
            runner.inside() {
              sh './run-shellcheck.sh'
            }
          }
        }
      }
    }
    stage('Audit') {
      steps {
        script {
          dir('web-client') {
            def runner = docker.build 'lint', '-f Dockerfile.test .'
            runner.inside('-v /home/tomcat:/home/tomcat') {
              sh 'npm audit'
            }
          }
        }
      }
    }
    stage('Lint') {
      steps {
        script {
          dir('web-client') {
            def runner = docker.build 'lint', '-f Dockerfile.test .'
            runner.inside('-v /home/tomcat:/home/tomcat') {
              sh 'npm run lint'
            }
          }
        }
      }
    }
    stage('Test') {
      steps {
        script {
          dir('web-client') {
            def runner = docker.build 'lint', '-f Dockerfile.test .'
            runner.inside('-v /home/tomcat:/home/tomcat') {
              sh 'npm run test'
            }
          }
        }
      }
      post {
        success {
          dir('web-client') {
            publishHTML allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'coverage/lcov-report', reportFiles: 'index.html', reportName: 'Code Coverage Report', reportTitles: ''
          }
        }
      }
    }
    stage('SonarQube') {
      steps {
        script {
          withCredentials([
            string(credentialsId: 'UI_SONAR_TOKEN', variable: 'SONAR_TOKEN')
          ]) {
            def runner = docker.build 'sonar', '-f web-client/Dockerfile.sonar .'
            runner.inside("-e SONAR_ORG=${SONAR_ORG} -e GIT_SSH_COMMAND='ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no' -e AWS_DEFAULT_REGION=us-east-1 -v /etc/passwd:/etc/passwd") {
              dir('web-client') {
                sh './verify-sonarqube-passed.sh'
              }
            }
          }
        }
      }
    }
    stage('Terraform - Dev') {
      when {
        expression {
          env.branch_name == 'develop'
        }
      }
      steps {
        script {
          def runner = docker.build 'terraform', '-f web-client/Dockerfile.terraform .'
          runner.inside() {
            dir('web-client/terraform/main') {
              sh '../bin/deploy-app.sh dev'
            }
          }
        }
      }
    }
    stage('Deploy Dev') {
      when {
        expression {
          env.branch_name == 'develop'
        }
      }
      steps {
        deployTo('dev')
      }
    }
    stage('Terraform - Staging') {
      when {
        expression {
          env.branch_name == 'staging'
        }
      }
      steps {
        script {
          def runner = docker.build 'terraform', '-f web-client/Dockerfile.terraform .'
          runner.inside() {
            dir('web-client/terraform/main') {
              sh '../bin/deploy-app.sh stg'
            }
          }
        }
      }
    }
    stage('Deploy Staging') {
      when {
        expression {
          env.branch_name == 'staging'
        }
      }
      steps {
        deployTo('stg')
      }
    }
    stage('Terraform - Prod') {
      when {
        expression {
          env.branch_name == 'master'
        }
      }
      steps {
        script {
          def runner = docker.build 'terraform', '-f web-client/Dockerfile.terraform .'
          runner.inside() {
            dir('web-client/terraform/main') {
              sh '../bin/deploy-app.sh prod'
            }
          }
        }
      }
    }
    stage('Deploy Prod') {
      when {
        expression {
          env.branch_name == 'master'
        }
      }
      steps {
        deployTo('prod')
      }
    }
  }
  post {
    always {
      deleteDir()
    }
  }
}

def deployTo(env) {
  def runner = docker.build 'deploy', '-f web-client/Dockerfile.deploy .'
  runner.inside('-e AWS_DEFAULT_REGION=us-east-1 -v /home/tomcat:/home/tomcat') {
    dir('web-client') {
      def domain="${EFCMS_DOMAIN}"
      def restApiId=sh(returnStdout: true, script: "aws apigateway get-rest-apis --query \"items[?name=='${env}-ef-cms'].id\" --output text").trim()
      sh "API_URL=https://efcms-${env}.${domain}/v1 npm run dist"
      def bucket = sh(returnStdout: true, script: "cd terraform/main && terraform output bucket").trim()
      s3Upload(
        bucket: "${bucket}",
        file: 'dist',
        path: "",
        cacheControl: 'no-cache'
      )
    }
  }
}
